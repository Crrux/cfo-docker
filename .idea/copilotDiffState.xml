<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="**/node_modules&#10;**/dist&#10;**/.env*&#10;/test&#10;*.sh&#10;*.bat&#10;/front/public/assets/video/Evenements.mp4&#10;/front/public/assets/video/Header.mp4&#10;&#10;/.vscode&#10;/.idea/&#10;" />
              <option name="updatedContent" value="**/node_modules&#10;**/dist&#10;**/.env*&#10;/test&#10;*.sh&#10;*.bat&#10;/front/public/assets/video/Evenements.mp4&#10;/front/public/assets/video/Header.mp4&#10;**/database.sqlite&#10;&#10;/.vscode&#10;/.idea/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/back/src/auth/auth.module.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/back/src/auth/auth.module.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import { Module } from '@nestjs/common';&#10;import { TypeOrmModule } from '@nestjs/typeorm';&#10;import { PassportModule } from '@nestjs/passport';&#10;import { JwtModule } from '@nestjs/jwt';&#10;import { ConfigModule, ConfigService } from '@nestjs/config';&#10;import { AuthService } from './auth.service';&#10;import { AuthController } from './auth.controller';&#10;import { User } from './entities/user.entity';&#10;import { LocalStrategy } from './local.strategy';&#10;import { JwtStrategy } from './jwt.strategy';&#10;&#10;@Module({&#10;  imports: [&#10;    TypeOrmModule.forFeature([User]),&#10;    PassportModule,&#10;    JwtModule.registerAsync({&#10;      imports: [ConfigModule],&#10;      useFactory: async (configService: ConfigService) =&gt; ({&#10;        secret: configService.get&lt;string&gt;('JWT_SECRET') || 'your-secret-key',&#10;        signOptions: { expiresIn: '15m' },&#10;      }),&#10;      inject: [ConfigService],&#10;    }),&#10;  ],&#10;  controllers: [AuthController],&#10;  providers: [AuthService, LocalStrategy, JwtStrategy],&#10;  exports: [AuthService],&#10;})&#10;export class AuthModule {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/back/src/auth/auth.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/back/src/auth/auth.service.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import { Injectable, UnauthorizedException } from '@nestjs/common';&#10;import { InjectRepository } from '@nestjs/typeorm';&#10;import { Repository } from 'typeorm';&#10;import { JwtService } from '@nestjs/jwt';&#10;import * as bcrypt from 'bcrypt';&#10;import { User } from './entities/user.entity';&#10;import { ChangePasswordDto } from './dto/change-password.dto';&#10;&#10;@Injectable()&#10;export class AuthService {&#10;  constructor(&#10;    @InjectRepository(User)&#10;    private userRepository: Repository&lt;User&gt;,&#10;    private jwtService: JwtService,&#10;  ) {}&#10;&#10;  async validateUser(username: string, password: string): Promise&lt;any&gt; {&#10;    const user = await this.userRepository.findOne({ where: { username } });&#10;    if (user &amp;&amp; (await bcrypt.compare(password, user.password))) {&#10;      const { password, ...result } = user;&#10;      return result;&#10;    }&#10;    return null;&#10;  }&#10;&#10;  async login(user: any) {&#10;    const payload = { username: user.username, sub: user.id };&#10;    const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });&#10;    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });&#10;&#10;    return {&#10;      access_token: accessToken,&#10;      refresh_token: refreshToken,&#10;      user: {&#10;        id: user.id,&#10;        username: user.username,&#10;        email: user.email,&#10;      },&#10;    };&#10;  }&#10;&#10;  async refreshToken(token: string) {&#10;    try {&#10;      const payload = this.jwtService.verify(token);&#10;      const user = await this.userRepository.findOne({&#10;        where: { id: payload.sub },&#10;      });&#10;&#10;      if (!user) {&#10;        throw new UnauthorizedException('Utilisateur non trouvé');&#10;      }&#10;&#10;      const newPayload = { username: user.username, sub: user.id };&#10;      const accessToken = this.jwtService.sign(newPayload, {&#10;        expiresIn: '15m',&#10;      });&#10;&#10;      return {&#10;        access_token: accessToken,&#10;      };&#10;    } catch (error) {&#10;      throw new UnauthorizedException('Token invalide');&#10;    }&#10;  }&#10;&#10;  async changePassword(userId: number, changePasswordDto: ChangePasswordDto) {&#10;    const user = await this.userRepository.findOne({ where: { id: userId } });&#10;&#10;    if (!user) {&#10;      throw new UnauthorizedException('Utilisateur non trouvé');&#10;    }&#10;&#10;    const isPasswordValid = await bcrypt.compare(&#10;      changePasswordDto.currentPassword,&#10;      user.password,&#10;    );&#10;&#10;    if (!isPasswordValid) {&#10;      throw new UnauthorizedException('Mot de passe actuel incorrect');&#10;    }&#10;&#10;    user.password = await bcrypt.hash(changePasswordDto.newPassword, 10);&#10;    await this.userRepository.save(user);&#10;&#10;    return { message: 'Mot de passe modifié avec succès' };&#10;  }&#10;&#10;  async findById(id: number): Promise&lt;User&gt; {&#10;    return this.userRepository.findOne({ where: { id } });&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/front/src/context/AuthContext.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/front/src/context/AuthContext.jsx" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import { createContext, useContext, useState, useEffect } from 'react';&#10;import { authService } from '../services/authService';&#10;&#10;const AuthContext = createContext(null);&#10;&#10;export const AuthProvider = ({ children }) =&gt; {&#10;  const [isAuthenticated, setIsAuthenticated] = useState(false);&#10;  const [user, setUser] = useState(null);&#10;  const [loading, setLoading] = useState(true);&#10;&#10;  // Vérifier l'authentification au chargement&#10;  useEffect(() =&gt; {&#10;    checkAuth();&#10;  }, []);&#10;&#10;  // Rafraîchir le token automatiquement toutes les 12 minutes (token expire dans 15min)&#10;  useEffect(() =&gt; {&#10;    if (isAuthenticated) {&#10;      const interval = setInterval(() =&gt; {&#10;        checkAuth();&#10;      }, 12 * 60 * 1000); // 12 minutes&#10;&#10;      return () =&gt; clearInterval(interval);&#10;    }&#10;  }, [isAuthenticated]);&#10;&#10;  const checkAuth = async () =&gt; {&#10;    if (authService.isAuthenticated()) {&#10;      try {&#10;        const profile = await authService.getProfile();&#10;        setUser(profile);&#10;        setIsAuthenticated(true);&#10;      } catch (error) {&#10;        console.error('Erreur lors de la vérification de l\'authentification:', error);&#10;        setIsAuthenticated(false);&#10;        setUser(null);&#10;      }&#10;    } else {&#10;      setIsAuthenticated(false);&#10;      setUser(null);&#10;    }&#10;    setLoading(false);&#10;  };&#10;&#10;  const login = async (username, password, rememberMe = false) =&gt; {&#10;    try {&#10;      const data = await authService.login(username, password, rememberMe);&#10;      setUser(data.user);&#10;      setIsAuthenticated(true);&#10;      return { success: true };&#10;    } catch (error) {&#10;      // eslint-disable-next-line no-console&#10;      console.error('Erreur de connexion:', error);&#10;      return {&#10;        success: false,&#10;        error: error.response?.data?.message || 'Erreur de connexion',&#10;      };&#10;    }&#10;  };&#10;&#10;  const logout = async () =&gt; {&#10;    try {&#10;      await authService.logout();&#10;    } finally {&#10;      setIsAuthenticated(false);&#10;      setUser(null);&#10;    }&#10;  };&#10;&#10;  const changePassword = async (currentPassword, newPassword) =&gt; {&#10;    try {&#10;      const result = await authService.changePassword(currentPassword, newPassword);&#10;      return { success: true, message: result.message };&#10;    } catch (error) {&#10;      return {&#10;        success: false,&#10;        error: error.response?.data?.message || 'Erreur lors du changement de mot de passe',&#10;      };&#10;    }&#10;  };&#10;&#10;  const value = {&#10;    isAuthenticated,&#10;    user,&#10;    loading,&#10;    login,&#10;    logout,&#10;    changePassword,&#10;    checkAuth,&#10;  };&#10;&#10;  return &lt;AuthContext.Provider value={value}&gt;{children}&lt;/AuthContext.Provider&gt;;&#10;};&#10;&#10;export const useAuth = () =&gt; {&#10;  const context = useContext(AuthContext);&#10;  if (!context) {&#10;    throw new Error('useAuth doit être utilisé dans un AuthProvider');&#10;  }&#10;  return context;&#10;};&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/front/src/sass/_offers.sass">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/front/src/sass/_offers.sass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/front/src/sass/offers_bilan_button.sass">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/front/src/sass/offers_bilan_button.sass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>